//---------------------------------------------------------------------------


#pragma hdrstop

#include "Algorithms.h"
#include "Points.h"
#include <deque>

extern int horizontalNumber, verticalNumber;
extern Point **points;
extern Point *begin, *end;

bool Dijkstra()
{
	int xCur, yCur;
	for(int i = 0; i < horizontalNumber; i++)
	{
		for(int j = 0; j < verticalNumber; j++)
		{
			if(points[i][j].color == clBlack)
				points[i][j].isPassed = 1;
			else
				points[i][j].isPassed = 0;
			points[i][j].distance = 1000000000;
		}
	}
	points[begin->posX][begin->posY].distance = 0;
	while(!allIsPassed())
	{
		if(!FindMinDistance(xCur, yCur))
			break;
		if(xCur != 0)
			if( points[xCur][yCur].distance + points[xCur - 1][yCur].GetDistance() <
			   points[xCur - 1][yCur].distance && points[xCur - 1][yCur].color != clBlack )
				points[xCur - 1][yCur].distance = points[xCur][yCur].distance + points[xCur-1][yCur].GetDistance();
		if(xCur != horizontalNumber - 1)
			if(points[xCur][yCur].distance + points[xCur + 1][yCur].GetDistance() <
			   points[xCur + 1][yCur].distance && points[xCur + 1][yCur].color != clBlack)
				points[xCur + 1][yCur].distance = points[xCur][yCur].distance + points[xCur + 1][yCur].GetDistance();
		if(yCur != verticalNumber-1)
			if(points[xCur][yCur].distance + points[xCur][yCur + 1].GetDistance() <
			   points[xCur][yCur + 1].distance && points[xCur][yCur + 1].color != clBlack)
				points[xCur][yCur + 1].distance = points[xCur][yCur].distance + points[xCur][yCur + 1].GetDistance();
		if(yCur != 0)
			if(points[xCur][yCur].distance + points[xCur][yCur - 1].GetDistance() <
			   points[xCur][yCur - 1].distance && points[xCur][yCur - 1].color != clBlack)
				points[xCur][yCur - 1].distance = points[xCur][yCur].distance + points[xCur][yCur - 1].GetDistance();
		points[xCur][yCur].isPassed = 1;
	}
	if(points[end->posX][end->posY].distance == 1000000000)
		return false;
	else
		return true;
}

bool Moore()
{
	for(int i = 0; i < horizontalNumber; i++)
		{
			for(int j = 0; j < verticalNumber; j++)
			{
				points[i][j].isPassed = 0;
				points[i][j].distance = -1;
			}
		}
		std::deque<Point> myDeque;
		points[begin->posX][begin->posY].distance = 0;
		points[begin->posX][begin->posY].isPassed = 1;
		myDeque.push_back(points[begin->posX][begin->posY]);
		while(!myDeque.empty())
		{
			Point cur = myDeque.front();
			Point newPoint;
			myDeque.pop_front();
			int xCur = cur.posX;
			int yCur = cur.posY;
			if(xCur != 0)
			{
				if(points[xCur - 1][yCur].color != clBlack && points[xCur - 1][yCur].isPassed != 1)
				{
				points[xCur - 1][yCur].isPassed = 1;
				points[xCur - 1][yCur].distance = cur.distance + 1;
				myDeque.push_back(points[xCur - 1][yCur]);
				}
			}
			if(xCur != horizontalNumber - 1)
			{
				if(points[xCur + 1][yCur].color != clBlack && points[xCur + 1][yCur].isPassed != 1)
				{
				points[xCur + 1][yCur].isPassed = 1;
				points[xCur + 1][yCur].distance = cur.distance + 1;
				myDeque.push_back(points[xCur + 1][yCur]);
				}
			}
			if(yCur != verticalNumber - 1)
			{
				if(points[xCur][yCur + 1].color != clBlack && points[xCur][yCur + 1].isPassed != 1)
				{
				points[xCur][yCur + 1].isPassed = 1;
				points[xCur][yCur + 1].distance = cur.distance + 1;
				myDeque.push_back(points[xCur][yCur + 1]);
				}
			}
			if(yCur != 0)
			{
				if(points[xCur][yCur-1].color != clBlack && points[xCur][yCur - 1].isPassed != 1)
				{
				points[xCur][yCur - 1].isPassed = 1;
				points[xCur][yCur - 1].distance = cur.distance + 1;
				myDeque.push_back(points[xCur][yCur - 1]);
				}
			}
		}
		return points[end->posX][end->posY].isPassed != 0;
}

bool FindMinDistance(int& x, int& y)
{
	x=0; y=0;
	int dist = 999999999;
	for(int i = 0; i < horizontalNumber; i++)
	{
		for(int j = 0; j < verticalNumber; j++)
		{
			if(points[i][j].distance < dist && points[i][j].isPassed == 0)
			{
				dist = points[i][j].distance;
				x = i;
				y = j;
			}
		}
	}
	return dist != 999999999;
}

bool allIsPassed()
{
	for(int i = 0; i < horizontalNumber; i++)
		for(int j = 0; j < verticalNumber; j++)
			if(points[i][j].isPassed == 0)
				return false;
	return true;
}

bool isUseDijkstra()
{
	for(int i = 0; i < horizontalNumber; i++)
		for(int j = 0; j < verticalNumber; j++)
			if(points[i][j].color != clBlack && points[i][j].color != clWhite)
				return true;
	return false;
}
//---------------------------------------------------------------------------

#pragma package(smart_init)
